* æ/Rashomon

Rashomon constructs a datastructure from a collection of events.

It offers a solution similar to multimethods but based on structure and functions, without special forms.

** The name

The term /[[https://en.wikipedia.org/wiki/Rashomon_effect][Rashomon effect]]/ is used to describe the situation when multiple observers have different, and often contradictory, interpretations of the same event. It is named for Kurosawa's classic 1950 film /[[https://en.wikipedia.org/wiki/Rashomon][Rashomon]]/, where four witnesses to a man's murder offer contradictory statements at the subsequent trial.

*** Terminology

Rashomon uses the word ~perspective~ for the function associated with an event, and the word ~testimony~ to describe the datastructure produced by rebuilding — in homage to its eponym.

** Usage

Invoke a function from the command line:
#+begin_src bash
clojure -X ae.rashomon/foo :bar
#+end_src

Run the project's tests:
#+begin_src bash
clojure -X:test
#+end_src

Use the project's core functions:
#+begin_src clojure
(require '[ae.rashomon :as r]
         '[ae.rashomon.event :as r.event])
#+end_src

We need to define our perspectives, functions associated with each type of event.
#+begin_src clojure
(def persps {:ae.rashomon.event.type/created
             (fn [_ {:keys [::name]}] {:name name :active? true})
             :ae.rashomon.event.type/deactivated
             (fn [t _] (assoc t :active? false))})
#+end_src

Each type of event can contain a variety of infortmation for use be each perspective. The only required key is :ae.rashomon.event/type and whatever will be needed when applying the perspective.
#+begin_src clojure

(def created {::r.event/type :ae.rashomon.event.type/created
              ::name "Fubar"})

(def activated {::r.event/type :ae.rashomon.event.type/activated})

(def deactivated {::r.event/type :ae.rashomon.event.type/deactivated})
#+end_src

We can use ~build~ to create the datastructure:
#+begin_src clojure
(r/build persps [created deactivated])
;; => {:name "Fubar", :active? false}
#+end_src

We can apply further events, but something is wrong...
#+begin_src clojure
(r/apply-event (build persps [created deactivated])
             persps activated)
;; => {:name "Fubar", :active? false}
#+end_src

 Nothing happened!? Our persps doesn't know what to do with the activated event. We need to add a perspective for :ae.rashomon.event.type/activated:
#+begin_src clojure
(r/apply-event (r/build persps [created deactivated])
             (assoc persps :ae.rashomon.event.type/activated
                    (fn [t _] (assoc t :active? true)))
             activated)
;; => {:name "Fubar", :active? true}
#+end_src

The same can be done for multiple events:
#+begin_src clojure
(r/apply-events t persps [e1 e2 e3])
#+end_src

The initial event must be applicable to a nil testimony if one is to call ~ae.rashomon/build~.


The collection of events that is passed to ~apply-events~ and ~build~ doesn't have to be be a list, a set works just as well as long as the order the events are applied is irrelevant. The collection will be used with ~reduce~, so as long as it works with that it will be fine.

** Comparison to multimethods

TODO

** Specs

See [[file:src/ae/rashomon/specs.clj]] for specs describing the structures used in Rashomon. If you are unfamiliar with Clojure Spec, [[file:test/ae/rashomon/specs_test.clj]] shows examples of the structures themselves.

** Future

*** Use custom event-type key

All Rashomon functions should allow a custom ~event-type~ key as an optional final argument so that one can use events and perspectives that use the the user's key, instead of ~:ae.rashomon.event/type~.
